<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Intro to Algorithms - Girl Develop It Philly</title>

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/gdisunny.css" id="theme">
	<link rel="stylesheet" href="css/theme/styles.css">

	<!-- For syntax highlighting -->
	<!-- light editor--><link rel="stylesheet" href="lib/css/light.css">
	<!-- dark editor<link rel="stylesheet" href="lib/css/dark.css">-->

	<!-- If use the PDF print sheet so students can print slides-->

	<link rel="stylesheet" href="css/print/pdf.css" type="text/css" media="print">
	<link rel="icon" type="image/x-icon" href="css/images/favicon.ico" />
	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->

	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>

	<script type="text/javascript" src="js/viz.js"></script>

	<script type="text/vnd.graphviz" id="konigsberg">
		graph K {
			C -- A [ label=e ];
			C -- A [ label=d ];
			C -- D [ label=g ];
			A -- D [ label=c ];
			A -- B [ label=a ];
			A -- B [ label=b ];
			B -- D [ label=f ];

			{ rank=same; A,D }
		}
	</script>

	<script type="text/vnd.graphviz" id="euler">
			graph E {
			    node[shape="point", height="0.2"];
				edge[penwidth="2"];

				1 -- 3
				3 -- 5
				5 -- 7
				2 -- 4
				4 -- 6
				6 -- 8
				1 -- 4
				2 -- 3
				5 -- 8
				6 -- 7
				3 -- 4
				5 -- 6

				{ rank=same; 1,3,5,7 }
				{ rank=same; 2,4,6,8 }
			}
	</script>

	<script type="text/vnd.graphviz" id="DFS">
		graph D {
			a -- b
			a -- c
			c -- d
			c -- e
			d -- f
			d -- g
			b -- j
		}
	</script>

</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
	<!-- Introduction -->
	<section>
		<h3>Intro to Algorithms</h3>
		<div>Slides: bit.ly/gdi-algo</div>
		<img src="css/images/philly_logo_badge.jpg" alt="Girl Develop It Philly" style='height: 300px; width: 300px; border: 0px;'>
<br/>
	</section>

	<section>
		<h3>Welcome!</h3>
		<div>
			<p>Girl Develop It is here to provide affordable and accessible programs to learn software through mentorship and hands-on instruction.</p>
			<br/>
			<p>Some "rules":</p>
			<ul>
				<li>We are here for you</li>
				<li>Every question is important</li>
				<li>Help each other</li>
				<li>Have fun!</li>
			</ul>
		</div>
	</section>

	<section>
		<h3>Welcome!</h3>
		<p>One extra-special rule for this class:</p>
		<br />
		<div class='fragment'>Don't use the word "obviously" before explaining something to someone!</div>
		<br />
		<ul>
			<li class='fragment'>Algorithms class gets confusing. Calling something challenging "obvious" can come out sounding a little bit condescending.</li>
			<li class='fragment'>If the point you're about to explain is TRULY obvious ("clear, self-evident, or apparent"), then by definition you shouldn't need to explain it.</li>
		</ul>
	</section>

	<section>
		<h3>What we'll cover</h3>

		<ul>
			<li class='fragment'>What is an algorithm?</li>
			<li class='fragment'>How to solve a problem with an algorithm, including:
					<ul>
						<li class='fragment'>Stating a problem formally</li>
						<li class='fragment'>Writing psuedocode</li>
						<li class='fragment'>Proving correctness</li>
						<li class='fragment'>Analyzing runtime</li>
					</ul>
			</li>
			<li class='fragment'>Introduction to Graph Theory</li>
			<li class='fragment'>Introduction to Trees</li>
			<li class='fragment'>Introduction to Recursion</li>
			<li class='fragment'>Introduction to Sorting</li>
			<li class='fragment'>Introduction to Greedy algorithms</li>
		</uL>
	</section>

	<section>
		<h3>What we won't cover</h3>

		<ul>
			<li class='fragment'>A semester's worth of algorithms lectures</li>
			<li class='fragment'>Every algorithm ever</li>
			<li class='fragment'>...or really, most algorithms (<a href='http://en.wikipedia.org/wiki/List_of_algorithms' target='_blank'>see Wikipedia</a>)</li>
			<li class='fragment'>Rigorous proofs</li>
			<li class='fragment'>Advanced mathematical analysis</li>
		</ul>
	</section>

	<section>
		<h3>Warm-up exercise!</h3>
		<br />
		<p><strong>Your mission:</strong></p>
		<br />
		<p>Find a way to shake the hand of every person in the room in the shortest time possible, but in a way that you can be confident you really did shake everyone's hand.</p>
		<br />
		<p class='fragment'>What are some approaches you came up with?</p>
	</section>

<!-- End Introduction -->

	<section>
		<h3>What is an algorithm?</h3>

		<p>An <strong>algorithm</strong> is an explicit, precise, unambiguous, mechanically-executable sequence of elementary instructions.</p>

		<br />

		<p>The word derives from the name of the 9th century Persian mathematician al-Khwarizmi.
	</section>

	<section>
		<h3>What is an algorithm?</h3>

<p>Is this sequence of instructions from the gnomes on South Park an algorithm?</p>

		<pre><code>
Step 1: Collect underpants.

Step 2: ????

Step 3: Profit!
		</code></pre>

		<p class='fragment'><strong>Verdict: No, this is not an algorithm. Step 2 is not specific, and a machine could not execute it.</strong></p>
	</section>

	<section>
		<h3>What is an algorithm?</h3>

		<p>Is this sequence of instructions for taking out money from the ATM an algorithm?</p>
		<pre><code>
Step&nbsp;1: Insert card into ATM.

Step&nbsp;2: Type your PIN on keypad.

Step&nbsp;3: Enter an amount to withdraw less than your total balance.

Step&nbsp;4: Receive money.
		</code></pre>

		<p class='fragment'><strong>Verdict: Yes, this is an algorithm.</strong></p>
	</section>

	<section>
		<h3>What is an algorithm?</h3>

		<p>Is this sequence of instructions from my shampoo bottle an algorithm?</p>

		<pre><code>
Step 1: Lather.

Step 2: Rinse.

Step 3: Repeat.
		</code></pre>

		<p class='fragment'><strong>Verdict: No, this is not an algorithm. Step 3 is ambiguous: what do we repeat, and until when?</strong></p>
	</section>

	<section>
		<h3>Exercise!</h3>
		<p><strong>Your mission: Think!</strong></p>
		<br />
		<p>What are some algorithms from your everyday life?</p>
		<br />
		<p>What are some algorithms you've encountered while programming?</p>
	</section>

	<section>
		<h3>Why bother learning algorithms?</h3>
		<h4>a.k.a. Why are you here?</h4>

		<ul>
			<li class='fragment'>It's like weight lifting for your brain. Exercise the muscles now so that they're ready to use when you need them.</li>
			<li class='fragment'>It will help you think of techniques for solving problems.</li>
			<li class='fragment'>It will expose you to some classic problems in computer science, which are often referenced in articles, tech talks, and interview questions.</li>
		</ul>
	</section>

	<section>
		<h3>How to solve a problem with an algorithm</h3>

		<p class='fragment'><strong>1. State the problem formally.</strong></p>

		<br />
		<p class='fragment'>Be as clear as possible. Use generalized variables instead of specific examples or instances of the problem.</p>

		<br />
		<p class='fragment'><strong>Bad:</strong> Sort some numbers like \((51, 62, 27, 3, 94)\).</p>
		<p class='fragment'><strong>Good:</strong> Sort an array of integers \(A_{1}, A_{2}, \ldots A_{n}\) in increasing order.</p>
	</section>

	<section>
		<h3>Exercise!</h3>
		<p>Can you transform this loosely-defined instance of a problem into a well-defined statement of a more generic problem?<p>
		<br />
		<p class='fragment'>Let's say I gave you five blocks with the weights of 1 pound, 2 pounds, 5 pounds, 8 pounds, and 10 pounds, respectively. Could you fill a sack with blocks so that its weight is exactly 21 pounds?</p>
		<br />
		<p class='fragment'>Interested in thinking more about this? It's called the "Knapsack Problem".</p>
	</section>

	<section>
		<h3>How to solve a problem with an algorithm</h3>

		<p class='fragment'>
			<strong>2. Find a solution to the problem*</strong>
			<br />
			<small>* Note: this step in particular makes this list NOT an algorithm</small>
		</p>

		<br />
		<p class='fragment'>You might solve the problem using known techniques, ingenuity, or a little bit of both.</p>

		<br />
		<p class='fragment'>Find a way to express your solution to others, perhaps through the use of <strong>pseudocode</strong>.</p>
	</section>

	<section>
		<h3>Pseudocode</h3>
		<ul>
			<li class='fragment'>Uses the structure of formal programming languages and mathematics.</li>
			<li class='fragment'>Breaks algorithms down into primitive steps.</li>
			<li class='fragment'>The primitive steps may be written using mathematics, pure English, or an appropriate mixture of the two.</li>
			<li class='fragment'>Reveals the internal structure of the algorithm but hides irrelevant implementation details.</li>
			<li class='fragment'>Makes the algorithm much easier to understand, analyze, debug, and implement.</li>
		</ul>
	</section>

	<section>
		<h3>Pseudocode</h3>

		<p>Here is an algorithm for singing "99 Bottles of Beer on the Wall", for arbitrary values of 99:</p>

		<br />
		<p class='fragment'>BottlesOfBeer(\(n\)):</p>
		<pre class='fragment'><code>
For i &larr; n down to 1
  Sing "i bottles of beer on the wall, i bottles of beer,"
  Sing "Take one down, pass it around,"
  Sing "i − 1 bottles of beer on the wall."
Sing "No bottles of beer on the wall, no bottles of beer,"
Sing "Go to the store, buy some more, n bottles of beer on the wall."
		</code></pre>
	</section>

	<section>
		<h3>Handshake problem</h3>

		<p>Find a way to shake the hand of every person in the room in the shortest time possible, but in a way that you can be confident you really did shake everyone's hand.</p>

		<br />

		<p class='fragment'>
			One possible solution:
			<br /><br />
			Stand in two parallel lines facing each other. Shake hands with the person in front of you. Take a step to the left, where the last person at the end of the line moves to the beginning of the other line. Continue this process until you have shaken everyone's hand.
		</p>
	</section>

	<section>
		<h3>Handshake problem</h3>
		<p>Let's express it with pseudocode!</p>

		<br />
		<p>HandshakeWithEveryone(\(P[1 .. n]\)):</p>

		<pre><code>
&lang;&lang;i represents the number of people you still need to shake hands with&rang;&rang;
for i &larr; n down to 2
	&lang;&lang;shake hands&rang;&rang;
	line1 &larr; P[1 .. n/2]
	line2 &larr; P[n/2 + 1 .. n]
	ShakeHands(line1, line2);

	&lang;&lang;shift over one, and wrap the last guy&rang;&rang;
	P&rsquo;[n] = P[1]
	for j &larr; n down to 2
	&nbsp;	P&rsquo;[j-1] = P[j]
	P &larr; P&rsquo;
		</code></pre>

		<aside class='notes'>
			<ul>
				<li>Mention implementation details: Assuming n is even</li>
				<li>Mention time it takes to run ShakeHands</li>
			</ul>
		</aside>
	</section>

	<section>
		<h3>Exercise!</h3>

		<p>Write pseudocode that prints the lyrics of the song "BINGO" for arbitrary long names of dogs.</p>

		<em>
		<br />There was a farmer who had a dog
		<br />And BINGO was his name-o
		<br />B-I-N-G-O, B-I-N-G-O, B-I-N-G-O
		<br />And BINGO was his name-o
		<br />There was a farmer who had a dog
		<br />And BINGO was his name-o
		<br />(clap)-I-N-G-O, (clap)-I-N-G-O, (clap)-I-N-G-O
		<br />...
		</em>
	</section>

	<section>
		<h3>How to solve a problem with an algorithm</h3>

		<p class='fragment'><strong>3. Prove your algorithm is correct.</strong></p>
		<ul>
			<li class='fragment'>We must convince our audience (and ourselves!) that the algorithm actually does what it's supposed to do.</p>
			<li class='fragment'>The algorithm must be correct for <em>all possible</em> inputs.  It's not enough to show that the algorithm does the right thing on some example input.</li>
			<li class='fragment'>Usually requires a formal, mathematical proof of correctness.</li>
		</ul>
	</section>

	<section>
		<h3>Mathematical proofs</h3>

		<p class='fragment'>Just kidding. We're totally not going to cover this today; it would need a class of its own.</p>

		<p class='fragment'>In lieu of knowing how to construct formal proofs, you can do a few other things in practice:</p>
			<ul>
				<li class='fragment'>Try to reason, even informally, about why your algorithm is correct.</li>
				<li class='fragment'>Explain your algorithm to a peer. You'll have to be very clear to convince your peer, and your peer's feedback can be valuable.</li>
				<li class='fragment'>If you're coding, write unit tests that cover all possible inputs.</li>
			</ul>
	</section>

	<section>
		<h3>How to solve a problem with an algorithm</h3>

		<p>
			<strong>4. Analyze the runtime of your algorithm.</strong>
			<br />
			<small>(and/or storage space needed to execute the algorithm)</small>
		</p>

		<p class='fragment'>We want to communicate how long our algorithm will take to execute, and we want to be able to compare it against other algorithms claiming to do the same task.</p>

		<p class='fragment'>It's impossible to predict what size input your algorithm is going to have to operate on, so we express runtime in terms of the <strong>size of the input</strong>.</p>

	</section>

	<section>
		<h3>Analyzing runtime</h3>

		<p>Let's consider the expression \(2x + 7\) for different inputs of size \(x\):</p>

		<table>
		<tr class='fragment'>
			<td style='width: 50%;'>If \(x=0\):</td><td style='width: 50%;'> \(2*0 + 7 = 7\)</td>
		</tr><tr class='fragment'>
			<td style='width: 50%;'>If \(x=1\):</td><td style='width: 50%;'> \(2*1 + 7 = 9\)</td>
		</tr><tr class='fragment'>
			<td style='width: 50%;'>If \(x=10\):</td><td style='width: 50%;'> \(2*10 + 7 = 27\)</td>
		</tr><tr class='fragment'>
			<td style='width: 50%;'>If \(x=100\):</td><td style='width: 50%;'> \(2*100 + 7 = 207\)</td>
		</tr><tr class='fragment'>
			<td style='width: 50%;'>If \(x=10000\):</td><td style='width: 50%;'> \(2*10000 + 7 = 20007\)</td>
		</tr>
		</table>

		<br />
		<p class='fragment'>The constant \(7\) becomes less and less a part of the answer as the size of \(x\) gets bigger and bigger.</p>
	</section>

	<section>
		<h3>Analyzing runtime</h3>

		<p><strong>Asymptotic analysis</strong> is the method of characterizing a mathematical function by how it trends as the input size approaches infinity.</p>

		<br />

		<p class='fragment'>In computer science, we use <strong>big O notation</strong> to talk about asymptotic growth.</p>

		<br />
		<div class='fragment'>\(2x + 7 = O(x)\)
			<br />
			<small>You say: "two ex plus seven is big oh of ex"</small>
		</div>
	</section>

	<section>
		<h3>Analyzing runtime</h3>

		<p class='fragment'>To find the big O function, you can often "drop" terms from your expression that grow significantly slower than the leading term.</p>

		<br />
			<div class='fragment'>\(2x + 7 = O(x)\)</div>
			<div class='fragment'>\(5x^{2} + 15x + 8 = O(x^{2})\)</div>
			<div class='fragment'>\(2x! + 6x + 37 = O(x!)\)</div>

		<br />

		<p class='fragment'>In practice, you shouldn't have to think too much about complicated equations, but it's important to understand where the idea of "big O" comes from.</p>
	</section>

	<section>
		<h3>Analyzing runtime</h3>

		<p>For your purposes, it's probably best to think about big O conceptually.</p>

		<br />
		<p class='fragment'><strong>Example 1:</strong> What is the first element of the array \(A[1 .. n]\)?</p>

		<br />
		
		<p class='fragment'><strong>Algorithm:</strong> Simply return \(A[1]\), regardless of the size of the number of elements, \(n\).</p>

		<br />

		<p class='fragment'>This took us a <strong>constant</strong> amount of time, a.k.a. \(O(1)\).</p>
	</section>

	<section>
		<h3>Analyzing runtime</h3>

		<p><strong>Example 2:</strong> What is the largest number in the array \(A[1 .. n]\)?</p>

		<pre class='fragment'><code>
b &larr; -infinity
for i &larr; 1 to n
  if A[i] &gt; b
     b &larr; A[i]
return b
		</code></pre>

		<br />

		<p class='fragment'>We had to <strong>loop over every element</strong> of the array, so we had to look at all \(n\) inputs.</p>

		<p class='fragment'>This took us a <strong>linear</strong> amount of time, a.k.a. \(O(n)\).</p>
	</section>

	<section>
		<h3>Analyzing runtime</h3>

		<p><strong>Example 3:</strong> Does the array \(A[1 .. n]\) contain any duplicates?</p>

		<pre class='fragment'><code>
for i &larr; 1 to n
  for j &larr; 1 to n
	if i = j
	  continue
	else if A[i] = A[j]
	  return true
return false
		</code></pre>

		<br />

		<p class='fragment'>We have <strong>two nested loops</strong> over the array.</p>

		<p class='fragment'>This took us a <strong>quadratic</strong> amount of time, a.k.a. \(O(n^{2})\).</p>
	</section>

	<section>
		<h3>How to solve a problem with an algorithm</h3>

		<p>Let's review what we've learned!</p>

		<br />
		<ol>
			<li class='fragment'>State the problem formally.</li>
			<li class='fragment'>Find a solution to the problem.</li>
			<li class='fragment'>Prove your algorithm is correct.</li>
			<li class='fragment'>Analyze the runtime of your algorithm.</li>
		</ol>

		<br />
		<br />
		<p class='fragment'>Got it? Good. Now let's have some fun!</p>

	</section>

	<section>
		<h3>Graph Theory</h3>

		<p>A <strong>graph</strong> is defined as \(G = (V, E)\), where \(V\) is a set of objects called <strong>vertices</strong> (singular: vertex), and \(E\) is a set of <strong>edges</strong> joining pairs of vertices.</p>

		<br />

		<p class='fragment'>Graphs represent a set of concepts and how they are related to each other, and they can be used to model many concepts.</p>
	</section>

	<section>
		<h3>Graph Theory in Real Life</h3>

		<br />
		<p>Transit maps, like PATCO:</p>
		<br />
		<img src="images/patco.png" />

	</section>

	<section>
		<h3>Graph Theory in Real Life</h3>

		<p>Flight maps, like for Spirit Airlines:</p>
		<img src="images/spirit.jpg" />
	</section>

	<section>
		<h3>Graph Theory in Real Life</h3>

		<p>The possibilities are endless.  Here's a few more:</p>

		<ul>
			<li class='fragment'>Wikipedia articles and the hyperlinks between them</li>
			<li class='fragment'>Users or objects on a social media site and the "friendships" or "likes" between them</li>
			<li class='fragment'>Relationships of movie actors, so as to play <a href='http://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon' target="_blank">Six Degrees of Kevin Bacon</a></li>
		</ul>
		<br /><br />
		<p class='fragment'>Once you have modeled your problem as a graph, then you can use Graph Theory to solve your problem.</p>
	</section>

	<section>
		<h3>Bridges of Königsberg</h3>
		<p>The city of Königsberg in Prussia was set on both sides of the Pregel River, and included two large islands which were connected to each other and the mainland by <strong>seven bridges</strong>.</p>
		<img src="images/konigsberg.png" />
	</section>

	<section>
		<h3>Bridges of Königsberg</h3>
		<p><strong>The big question:</strong></p>
		<p>Is it possible to find a walk through the city that would cross each bridge once and only once?</p>
		<div>
			<img class='fragment' src="images/euler.png" style="height: 200px;">
			<span class='fragment' id="konigsberg_output"></span>
		</div>
		<p class='fragment'><strong>Exercise</strong>: Try it!</p>
	</section>

	<section>
		<h3>Bridges of Königsberg</h3>
		<p><strong>The key piece of intuition:</strong></p>
		<br />
		<div>Except at the beginning and end of the journey, whenever one enters a vertex by a bridge, one also has to leave that vertex by a bridge.</div>
		<br />
		<p class='fragment'>It follows that every vertex (except for the start and the finish) must have an <strong>EVEN</strong> number of edges touching it.</p>
	</section>

	<section>
		<h3>Bridges of Königsberg</h3>
		<p><strong>Definition:</strong> We call the number of edges coming out of a vertex the <strong>degree</strong> of the vertex.</p>
		<br />
		<p class='fragment'><strong>Definition:</strong> A <strong>walk</strong> or a <strong>path</strong> is a sequence of vertices and edges, where each edge's endpoints are the preceding and following vertices in the sequence.</p>
		<br />
		<p class='fragment'><strong>Definition:</strong> A <strong>tour</strong> or a <strong>circuit</strong> is a walk where the vertices at the beginning and end of the walk are the same.</p>
	</section>

	<section>
		<h3>Bridges of Königsberg</h3>
		<p>This problem was studied by <strong>Leonard Euler</strong> (pronounced "oil-er") in 1735 and laid the foundations for graph theory and topology.</p>
		<br />
		<p class='fragment'>In Euler's honor, we say that a graph that contains exactly <strong>zero or two vertices</strong> of <strong>even degree</strong> has an <strong>Eulerian path</strong> (or walk).</p>
		<br />
		<p class='fragment'>If the start and endpoints are the same vertex, then it is called an <strong>Eulerian tour</strong> (or circuit).</p>
	</section>
	<section>
		<h3>Bridges of Königsberg</h3>
		<br />
		<img src="images/euler.png" style="height: 200px;">
		<p><strong>Conclusion</strong>: Since the graph corresponding to the Königsberg bridges has four vertices of odd degree, it cannot have an Eulerian path.</p>
	</section>

	<section>
		<h3>Exercises</h3>
		<p><strong>1.</strong> Find an Eulerian trail for the graph below:</p>
		<div id="euler_output"></div>
		<br />
		<p><strong>2.</strong> A graph is called <strong>complete</strong> if <em>every pair</em> of distinct vertices has an <em>edge</em> between them. (No loops from a vertex back to itself.) Draw the <strong>complete graph</strong> on 1 vertex, 2 vertices, 3 vertices, 4 vertices, and 5 vertices.</p>
	</section>


	<section>
		<h3>Graph traversal</h3>
		<br />
		<p><strong>Definition:</strong> A graph is <strong>connected</strong> if it is in one piece; that is, if a path exists between any pair of vertices.</p>
		<br />
		<p class='fragment'>Suppose we have a connected graph where each vertex has a label, and we're looking for a vertex with a particular label.</p>
		<br />
		<p class='fragment'>There are two well-known algorithms that we can use.</p>
	</section>

	<section>
		<h3>Graph traversal</h3>
		<br />
		<p><strong>Depth-first search</strong> (DFS): Starting from some vertex, explore as far as possible down each branch before backtracking.</p>
		<img class='fragment' src="images/dfs.png" />
	</section>

	<section>
		<h3>Graph Traversal</h3>
		<br />
		<p><strong>Breadth-first search</strong> (BFS): Starting from some vertex, fan out to as many vertices as possible before exploring deeper into the tree.</p>
		<img class='fragment' src="images/bfs.png">
	</section>

	<section>
		<h3>Graph Traversal</h3>
		<p>When you should use DFS versus BFS is something that varies on the nature of the graph you're searching.</p>
		<br />
		<p class='fragment'>If the graph expands rapidly, then it may take too much memory to remember all the nodes you're fanning through for BFS.</p>
		<br />
		<p class='fragment'>If the graph is very deep, then it might take too much time getting lost down individual paths for DFS.</p>
	</section>

	<section>
		<h3>Exercise</h3>
		<p>Let's say you were looking for the vertex "f".  How many vertices do you have to check against when searching by DFS? by BFS?</p>
		<div id="DFS_output"></div>
	</section>


	<section>
		<h3>Graph Theory: Wrap up</h3>
		<br />
		<div>You can use graphs to model lots of real-world problems, and then apply algorithms to the resulting graph to solve those problems.</div>

		<br />
		<p class='fragment'>If you like this stuff, then you might want to look into more Graph Theory problems, such as:</p>
		<ul>
			<li class='fragment'>Traveling Salesman Problem</li>
			<li class='fragment'>Four Color Theorem</li>
			<li class='fragment'>Hamiltonian paths</li>
			<li class='fragment'>Minimum spanning tree</li>
			<li class='fragment'>Max Flow / Min Cut</li>
		</ul>
	</section>

	<section>
		<h3>Day 2: Warm-up exercise!</h3>
		<small>Reading these slides ahead of time? This slide will move around to be in the actual place where day 2 starts.  Plus, some content might change depending on how quickly we get through material on Day 1.</small>
		<br />
		<p><strong>Your mission:</strong></p>
		<br />
		<p>Sort yourselves in height order following the <strong>Merge Sort</strong> algorithm.</p>

		<br />
		<p>We'll walk through it together!</p>
	</section>

	<section>
		<h3>Merge Sort Part 1: Divide</h3>
		<ol>
			<li>Start as one unorganized clump of \(n\) humans.</li>
			<li class='fragment'>Split into two even groups.</li>
			<li class='fragment'>Each of the two groups splits into two groups (total: four groups of \(n/4\) humans).  Keep track of how you are splitting.</li>
			<li class='fragment'>Continue splitting up (and keep track of the splits!) until there are \(n\) groups, each with \(1\) human.</li>
		</ol>
	</section>

	<section>
		<h3>Merge Sort Part 2: Merge</h3>
		<ol>
			<li>Each pair of humans that was the last to break apart should get back together into a group of 2.</li>
			<li class='fragment'>Compare between the two of you who is taller and who is shorter. Shorter person stands on the left side, taller person stands on the right side.</li>
			<li class='fragment'>Now the two pairs that originally split apart from each other work together to merge...
		</ol>
	</section>

	<section>
		<h3>Merge Sort Part 2: Merge</h3>
		<ol style='list-style-type: lower-alpha;'>
			<li>Starting from the SHORTEST person in each group, figure out who is truly the shortest. Let's say this person came from group A.  The shortest person moves to the left-most position. The other short person from group B stays put.</li>
			<li class='fragment'>The next-shortest person from group A now compares against the person who stayed put.</li>
			<li class='fragment'>Continue comparing until your two pairs are merged into a line of four.</li>
		</ol>
		<br/>
		<br/>
		<p class='fragment'>Continue this process until everyone has merged into a SINGLE line!</p>

		</ol>

	</section>

	<section>
		<h3>Reduction</h3>
		<br />
		<p><strong>Reducing</strong> one problem X to another problem Y means to write an algorithm for X that uses an algorithm for Y as a black box or subroutine.</p>
		<br />
		<p class='fragment'>The correctness of the resulting algorithm cannot depend in any way on <em>how</em> the algorithm for Y works. The only thing we can assume is that the black box solves Y correctly.</p>
		<br />
		<p class='fragment'>Think of the black box Y as MAGICAL.</p>
	</section>

	<section>
		<h3>Recursion</h3>
		<br />
		<p>Recursion is a particularly powerful kind of reduction, which can be described loosely as follows:</p>
		<br >
		<ul>
			<li class='fragment'>If the given instance of the problem is small or simple enough, just solve it.</li>
			<li class='fragment'>Otherwise, reduce the problem to one or more <em>simpler instances of the same problem</em>.</li>
		</ul>
	</section>

	<section>
		<h3>Recursion</h3>

		<br/>
		<p class='fragment'>When we reduce problem X to smaller versions of problem X, we rely on those smaller versions of problem X magically solving themselves.</p>

		<br />
		<p class='fragment'>My teacher used to call this the magic of the "Recursion Fairy".</p>
	</section>

	<section>
		<h3>Recursion</h3>

		<p>To solve a problem with recursion:</p>
		<br />
		<ul>
			<li class='fragment'>You need to be able to solve some sort of <strong>base case</strong>. This is often done on inputs of size 0 or 1.</li>
			<li class='fragment'>You need to be able to use the results that the recursion fairy gives you.</li>
			<li class='fragment'>Don't try to recurse over an infinite list of items.</li>
		</ul>
	</section>

	<section>
		<h3>Recursion: DFS</h3>
		<p>Remember Depth-First Search that we talked about before? We can express that as a recursive algorithm.</p>

		<br />
		<p class='fragment'>DFS(graph \(G\), vertex \(v\), searchterm \(i\)):</p>
		<pre class='fragment'><code>
if v is null
   return false
else if v's label matches i
   return true
else
   for every edge from v to other vertex u
      return DFS(G, u, i)
		</code></pre>
	</section>

	<section>
		<h3>Recursion: DFS</h3>
		<p>We've reduced the problem of finding label \(i\) in a huge graph \(G\) to finding label \(i\) in a slightly smaller graph, \(G\) less the vertex \(v\).</p>
		<br />
		<p class='fragment'>Once we have the answer from the subgraph, we can simply return it.</p>
		<br/>
		<p class='fragment'>And it just works.</p>
		<br />
		<p class='fragment'>Thanks, Recursion Fairy.</p>
	</section>

	<section>
		<h3>Exercise</h3>
		<p>Consider the following problem regarding the population of rabbits:</p>
		<ul class='fragment'>
			<li>Each pair of rabbits produces a new pair of offspring each month</li>
			<li>Rabbits become fertile in their second month of life</li>
			<li>Old rabbits never die</li>
		</ul>
		<br /><br />
		<p class='fragment'>If a pair of newborn rabbits are introduced in January, how many pairs of rabbits will there be at the end of the year?</p>
	</section>

	<section>
		<h3>Recursion: Fibonacci</h3>

		<br />
		<p>Perhaps it's useful to know that that problem was posed in 1202 by Leonardo Fibonacci...</p>
		<br />
		<p class='fragment'>We can express how to calculate a term in the Fibonacci series recursively!</p>
		<br />
		<p class='fragment'>Fibonacci(\(n\)):</p>
		<pre class='fragment'><code>
if (n &lt; 2)
   return n
else
   return Fibonacci(n-1) + Fibonacci(n-2)
		</code></pre>
	</section>

	<section>
		<h3>Recursion: Fibonacci</h3>

		<div>Fib(12) = Fib(11) + Fib(10)</div>
		<div class='fragment'>Fib(11) = Fib(10) + Fib(9)</div>
		<div class='fragment'>Fib(10) = Fib(9) + Fib(8)</div>
		<div class='fragment'>...</div>
		<div class='fragment'>Fib(3) = 1 + 1</div>
		<br />
		<p class='fragment'>Something to keep in mind: often with recursion, you repeat the same calculations over and over again as you recurse.</p>

		<p class='fragment'>If you have enough storage space, you can save some time by saving values as you calculate them. This is called <strong>memoization</strong>.</p>
	</section>

	<section>
		<h3>Recursion: Wrap up</h3>
		<br />
		<p>You can often solve problems by <strong>reducing</strong> a problem to another problem.</p>
		<br />
		<p class='fragment'>If you reduce a problem to one or more <strong>smaller instances of itself</strong> then you are performing <strong>recursion</strong>.</p>
		<br />
		<p class='fragment'>Solve for a small <strong>base case</strong> and be able to combine and return the results of the smaller, magical pieces.</p>
	</section>

	<section>
		<h3>Recursion: Wrap up</h3>
		<br />
		<p>Interested in solving problems with recursion? Look into some other problems that have elegant recursive solutions, such as:</p>
		<ul>
			<li class='fragment'>Towers of Hanoi<br/><small>(did you get to play with it before class?)</small></li>
			<li class='fragment'>Binary search</li>
			<li class='fragment'>Filesystem traversal</li>
			<li class='fragment'>Lots of other algorithms that can be expressed recursively!</li>
		</ul>
	</section>

	<section>
		<h3>Sorting Algorithms</h3>
		<br />
		<p>In today's warm-up, we sorted ourselves using the <strong>Merge Sort</strong> algorithm.</p>
		<br />
		<p>There are lots of other ways to sort things!</p>
	</section>

	<section>
		<h3>Sorting Algorithms</h3>

		<ol>
			<li><strong>Selection sort</strong> - repeatedly find the smallest element and append to the sorted list</li>
			<li class='fragment'><strong>Insertion sort</strong> - repeatedly take the first element and find it's place in the sorted list</li>
			<li class='fragment'><strong>Quick sort</strong> - repeatedly picks a pivot point and finds elements smaller and larger than the pivot</li>
			<li class='fragment'><strong>Merge sort</strong> - divide into small groups and repeatedly merge the sorted sub-lists</li>
			<li class='fragment'><strong>Radix sort</strong> - repeatedly sort by significant digits, from smallest to largest </li>
			<li class='fragment'><strong>Bubble sort</strong> - repeatedly compare pairs and swap if necessary until the list is sorted </li>
		</ol>

	</section>

	<section>
	<h3>Sorting Algorithms: Visuals!</h3>
		<br/>
		<iframe width="560" height="315" src="http://www.youtube.com/embed/kPRA0W1kECg" frameborder="0" allowfullscreen></iframe>
	</section>

	<section>
		<h3>Special topics</h3>
		<br />
		<p>If there's one thing I learned in computer science classes, it's that the speaker always talks about their own research last.</p>
		<br />
		<p class='fragment'>Today I'm going to teach you about <strong>coin sets</strong>.</p>
	</section>

	<section>
		<h3>Quick exercise</h3>
		<br />
		<p>Let's say you are a cashier and you owe somebody 43 cents.</p>
		<br />
		<p>1. What is the maximum number of coins you could give to the person?</p>
		<br />
		<p>2. What is the minimum number of coins you could give to the person?</p>
	</section>

	<section>
		<h3>Coin sets</h3>
		<br />
		<p>We can characterize the denominations of the coins of the US with an array of values called a <strong>coin set</strong>:</p>
		<br />
		<div class='fragment'>\((1, 5, 10, 25, 50, 100)\)</div>
		<br />
		<p class='fragment'>You'll use the minimum number of coins by always choosing the largest denomination coin that is not larger than the amount you have left to make.</p>
	</section>

	<section>
		<h3>Greedy algorithms</h3>
		<br />
		<p>A <strong>greedy algorithm</strong> is an algorithm that always makes the locally-optimal choice with the hopes of finding a global optimum.</p>
		<br />
		<p class='fragment'>Sometimes, a greedy algorithm finds an optimal solution.</p>
		<br />
		<p class='fragment'>For many problems, a greedy algorithm will NOT produce a correct solution. But sometimes it produces a close-enough approximation to the optimal result.</p>
	</section>

	<section>
		<h3>Non-Greedy coin sets</h3>
		<br />
		<p>Instead of the standard US coin set, what if you had the following coin set:</p>
		<div class='fragment'>\((1, 3, 4)\)</div>
		<br />
		<p class='fragment'>Spoiler alert: this is a coin set where the greedy algorithm WON'T always work. There is at least one <strong>counterexample to greediness</strong>.
		<br />
		<p class='fragment'><strong>Exercise:</strong> Find an amount of change that you CAN make greedily.  Find an amount of change that you CANNOT make greedily.</p>
	</section>

	<section>
		<h3>Non-Greedy coin sets</h3>
		<br />
		<p><a href="http://moneyart.biz/dd/" target="_blank">Antarctica Dream-Dollars</a>, the official currency of Nadiria, the lost colony of Antactica, is a fun example of a non-greedy coin set:</p>
		<br />
		<div class='fragment'>\((1, 4, 7, 13, 28, 52, 91, 365)\)</div>
		<br />
		<p class='fragment'>Were the coin set creators to have left off the 365 or were they to include rather the denomination 364, they would have a greedy coin set!</p>
	</section>

	<section>
		<h3>Non-Greedy coin sets</h3>
		<br />
		<p>A real-life example of a non-greedy coin set is the English system of currency from pre-1971:</p>
		<br />
		<div class='fragment'>\((\frac{1}{2}, 1, 3, 6, 12, 24, 30, 60, 240)\)</div>
	</section>

	<section>
		<h3>Final Wrap Up!</h3>
		<ul>
			<li class='fragment'>What is an algorithm?</li>
			<li class='fragment'>How to solve a problem with an algorithm, including:
					<ul>
						<li class='fragment'>Stating a problem formally</li>
						<li class='fragment'>Writing psuedocode</li>
						<li class='fragment'>Proving correctness</li>
						<li class='fragment'>Analyzing runtime</li>
					</ul>
			</li>
			<li class='fragment'>Introduction to Graph Theory</li>
			<li class='fragment'>Introduction to Trees</li>
			<li class='fragment'>Introduction to Recursion</li>
			<li class='fragment'>Introduction to Sorting</li>
			<li class='fragment'>Introduction to Greedy algorithms</li>
		</uL>
	</section>
<!-- Wrapping up! -->
	<section>
		<h3>Recommended Textbooks</h3>

		<p>
			<strong><u>Introduction to Algorithms</u> - Cormen, Leiserson, Rivest, Stein</strong> (<a href='http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844' target='_blank'>available on Amazon</a>)
			<br />About this book: a.k.a. "CLRS", a well-known advanced undergraduate textbook for a course in algorithms
		</p>
		<br />

		<p>
			<strong><u>Discrete Mathematics and its Applications</u> - Rosen</strong> (<a href='http://www.amazon.com/Discrete-Mathematics-Applications-Kenneth-Rosen/dp/0072899050' target='_blank'>available on Amazon</a>)
			<br />About this book: a well-known junior undergraduate textbook for a course in discrete mathematics, which is generally an expected prerequisite for algorithms
		</p>
	</section>

	<section>
		<h3>Recommended Textbooks</h3>
		<p>
		<strong><u>Introduction to Graph Theory</u> - Robin J. Wilson</strong><br />(<a href='http://www.amazon.com/Introduction-Graph-Theory-5th-Edition/dp/027372889X' target='_blank'>available on Amazon</a>)
		<br />About this book: An advanced undergraduate textbook for a course dedicated to the study of graph theory.
		</p>
	</section>

	<section>
		<h3>Jeff Erickson's Algorithms notes</h3>

		<img src='http://ws.engr.illinois.edu/directory/viewphoto/50176/240' style='float: right'/>
		<p>These notes provided some of the backbone of this class. Some definitions and examples in these slides were taken directly from these notes. Many thanks to Jeff for making his not-a-textbook an available resource.</p>
		<br />

		<a href='http://www.cs.illinois.edu/~jeffe/teaching/algorithms' target='_blank'>
			http://www.cs.illinois.edu/~jeffe/teaching/algorithms
		</a>

	</section>

	<section>
		<h3>Thank you for attending!</h3>
		<p>Please help us make this class better by completing this short survey:</p>
		<br/>
		<div><a target="_blank" href="http://bit.ly/algorithms-survey">http://bit.ly/algorithms-survey</a></div>
	</section>

	<!-- End of slides -->
</div>

<footer>
	<div class="copyright">
		Intro to Algorithms -- Girl Develop It Philly --
		<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/80x15.png" /></a>
	</div>
</footer>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
	$('script[type="text/vnd.graphviz"]').each(function(index, spec) {
		var rendered = Viz(spec.innerHTML, 'svg');
		$('#' + spec.getAttribute('id') + '_output').html(rendered);
	});

</script>

<script>

	// Full list of configuration options available here:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
		controls: true,
		progress: true,
		history: true,

		theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
		transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

		// Optional libraries used to extend on reveal.js
		dependencies: [
			{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
			{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
		]
	});

</script>

</body>
</html>

